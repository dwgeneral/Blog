> Redis 持久化机制

#### 什么是持久化
Redis 是一款基于内存的高性能键值对NoSQL数据库，写入到 Redis 中的数据会先被存储在内存中，而后再根据配置决定是否需要将数据存储到磁盘中，防止服务重启造成数据丢失。此之谓持久化。

Redis 支持多种持久化方式，定时快照RDB、AOF追加日志及RDB&AOF混合方式。

#### 定时快照RDB
RDB持久化既可以手动执行，也可以根据服务器配置选项定期执行，该功能可以将某个时间点上的数据库状态保存到一个RDB文件中。如果配置为定期执行，每隔固定时间检查是否满足持久化条件，如果满足，就创建一个包含整个数据集的快照文件(.rdb)。并将该文件保存到磁盘中。

RDB持久化功能所生成的(.rdb)文件是一个经过压缩的二进制文件，通过该文件可以还原生成RDB文件时的数据库状态。

Redis 的工作线程是单线程的，且制作快照的操作需要进行大量I/O操作，为了在制作快照时不影响Redis正常对外提供服务。Redis会通过系统调用 fork 出一个子进程来干这个事，主进程继续提供服务就好了。

注意，这里有一个极端场景，就是我在制作快照的同时，还在提供服务，那会造成已有数据的破坏吗？

答案是不会的，得益于操作系统多进程的Copy On Write机制。COW机制会进行 数据段页面 的分离，父进程要对其中一个页面的数据进行修改时，会被复制分离出来一份，对原有的数据没有影响，这也是为啥叫快照的原因，在 fork 出子进程进行快照的瞬间，内存里的数据就凝固了，不会再变了。

这种方式因为读写磁盘次数低，所以保证了 Redis 服务的快速，同时的一个弊端是，如果服务直接断电，则会丢失还没来得及进行快照的数据。

#### AOF追加日志
另一种持久化方式就是通过记录写操作来完成。通过将写操作记录到一个.aof文件中，事后回放该文件即可得到数据。这里的记录写操作频率有三个层级，分别对应 appendsync 参数三个可选值。
- always：每写操作一次，将 aof_buf缓冲区的所有内容写入到磁盘，完整性最强，但会造成性能下降
- everysec：默认级别，每秒钟定时刷一下系统Buffer，写入到磁盘，系统Buffer满了的话，也会自动写一次，它的问题是如果突然故障，可能会丢失1个buffer的数据，但概率很小
- no：完全由系统Buffer执行刷写，也可能会丢失1个buffer的数据，概率比everysec大一些

Redis 在收到客户端写指令后，会先进行参数校验，逻辑处理，如果没问题，再将操作存储到AOF日志中。这样做的目的是为了避免写入无效指令。比如我删除一个不存在的key，只有执行后我才知道这条根本不用记。这一点不同于 MySQL，它是先存储日志再做逻辑操作，这样可以保证即使宕机了，仍然可以通过之前保存的日志恢复数据，MySQL语法检查会过滤掉大部分无效指令，所以可以直接记录到日志。

对于一个长期运行的 Redis，AOF日志会越来越大，重放整个AOF耗时非常严重，所以我们需要对这个AOF文件瘦身。Redis 提供了 bgrewriteaof 指令对 AOF 日志进行瘦身。它的具体实现是：
- 开辟一个子进程对日志内容进行遍历转换，操作合并
- 直接读取该key当前状态的值，生成一条命令
- 序列化到一个新的AOF日志文件
- 完毕后再将操作期间发生的增量AOF日志追加到新AOF日志文件中
- 追加完毕后立即替换旧的，瘦身完成

同样的问题，持久化的同时，还在提供服务，会破坏已有数据吗？

答案也是不会的，Redis设置了一个AOF重写缓冲区，当Redis服务器执行完一个写命令后，它会同时将这个写命令发送给AOF缓冲区和AOF重写缓冲区，当子进程完成AOF重写工作之后，它会向父进程发送一个信号，告知其写完了，然后父进程收到信号后，将AOF重写缓冲区的所有内容写入到新的AOF文件中，完成新旧文件替换。

#### RDB & AOF 混合持久化
为了提高Redis服务重启加载数据的效率，可以采用混合持久化的方案。典型场景是 Redis重启时，先加载定时的 RDB 快照数据内容，然后再重放一小段时间的增量AOF。相比于重放全量AOF来说，更少的磁盘IO次数，效率得到大幅提高，相比于重放全量RDB来说，数据完整性更高。