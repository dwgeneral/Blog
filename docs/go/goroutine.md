> 不要通过共享内存来通信，而应该通过通信来共享内存。这是作为 Go 语言的主要创造者之一的 Rob Pike 的至理名言，这也充分体现了 Go 语言最重要的编程理念。

#### 内核态线程与用户态线程
说起并发模型，就一定要先聊线程，因为无论何种并发模型，到了操作系统层面，一定是以线程的形态发生的。我们知道，线程是处理器调度的基本单元，进程是资源分配的基本单位。每个进程启动时会由系统自动创建一个线程去执行任务，叫主线程。 单个进程中也可以存在多个线程，这些线程都是由已存在的线程创建出来的，创建的方式是通过系统调用。

根据资源访问权限的不同, 进程的运行空间分为 内核空间 和 用户空间。
- 内核空间：具有最高权限，可以直接访问所有资源，进程在内核空间内运行时，称为内核态
- 用户空间：访问受限的资源，不能直接访问内存等硬件设备，必须通过系统调用到内核中，才能访问特权资源，进程在用户空间时，称为用户态

进程是由内核来管理和调度的，进程的切换只能发生在内核态，所以进程上下文不仅包括了虚拟内存、栈、全局变量等用户空间资源，还包括了内核堆栈、寄存器等内核空间的状态。

从用户态到内核态的转变，需要通过系统调用来完成，具体来说：
- 一次系统调用的过程，会发生两次CPU上下文切换
- 系统调用过程中一直是同一个进程在运行
- 系统调用过程通常称为特权模式切换
- 先将CPU寄存器里用户态的指令位置，保存起来
- CPU寄存器加载内核态指令位置
- 跳转到内核态运行任务
- 系统调用结束后，CPU寄存器恢复原来保存的用户态，再切换到用户空间，继续运行进程

我们前面已经说过了，线程是调度的基本单位，而进程是资源拥有的基本单位。那么该怎么理解这句话呢？事实上，内核中的任务调度，调度的对象是线程，而进程只是给线程提供了虚拟内存、全局变量等资源。

- 当进程只有一个线程时，可以认为进程就等于线程
- 当进程拥有多个线程时，线程间会共享虚拟内存，这些资源在上下文切换时不需要修改
- 线程也有自己的私有数据，比如栈和寄存器，这些在上下文切换时需要保留

#### 线程实现模型
线程的实现模型主要有3类，分别是内核级线程模型、用户级线程模型和两级线程模型。
- 内核级线程模型
  - 用户线程与内核调度实体(内核线程)是一对一的关系，不同线程之间互不影响
  - 实现简单，直接借助OS提供的线程能力，可以跑在多个CPU核心上，实现了真正的并行
  - 每个线程由内核调度器独立调度，如果一个线程阻塞则不影响其他的线程
  - 但其创建、销毁以及上下文切换都是直接由内核来处理，性能影响大
  - 大部分编程语言的线程库(Linux的pthread, Java的java.lang.Thread, C++的std::thread等)都是直接对操作系统的线程进行一层封装
- 用户级线程模型（协程）
  - 用户线程与内核调度实体(内核线程)是多对一的关系，多个用户线程映射到一个内核线程上
  - 协程就是基于这种设计实现的
  - 协程的创建、销毁以及多个线程之间的协调等操作都是由用户自己实现的协程库来负责的
  - 这种方式更轻量化，对系统资源的消耗更小，可以创建的数量更多，上下文切换所花费的代价更低
  - 但如果某个协程上调用了阻塞式的系统调用(如用阻塞方式read网络IO)，那么基于此内核线程的上的所有协程都会被阻塞
  - 所以现在的协程库都会把自己的阻塞操作封装为非阻塞的形式，主动让出自己，让线程去执行其他协程，然后通过某种通知机制来让线程回来
- 混合线程模型(两级线程模型)
  - 用户线程与内核调度实体(内核线程)是多对多(M:N)的关系，其综合了上面两种模型的优点
  - 当某个内核线程因其上的协程任务阻塞而被内核调度出CPU时，当前与其关联的其他协程可以重新与其他内核线程建立关联
  - 这种动态关联机制的实现很复杂，需要用户自己实现，没错，Go 就是用的这种模型
  - Go 的 goroutine 调度器实现了协程到内核调度实体的调度，内核调度器实现了内核调度实体到CPU上的调度

#### Go 并发调度模型：G-P-M模型
在操作系统提供的内核线程之上，Go搭建了一个特有的两级线程模型。goroutine机制实现了M:N的线程模型，goroutine机制是协程的一种实现。
Go语言内置的调度器负责 goroutine 协程与内核线程之间的调度，所以理解 goroutine 机制的关键是理解这个调度器(scheduler)的实现

Go语言调度器(scheduler)由4个主要结构组成，分别是M、G、P、Sched，前三个定义在 runtime.h 中，Sched 定义在 proc.c 中
- M结构是 Machine，系统线程，也就是我们说的内核线程，它由操作系统管理，goroutine 跑在 Machine 之上。
- P结构是 Processor，处理器，主要用途是用来执行 goroutine，维护了一个 goroutine 队列，即 runqueue
- G结构是 goroutine 实现的核心结构，包含了栈、指令指针以及其他对调度 goroutine 很重要的信息
- Sched结构是调度器，维护 Machine 和 goroutine 队列以及调度器的一些状态信息等


#### Channel 通道
虽然我们在 Go 语言中也能使用共享内存加互斥锁进行通信，但是 Go 语言提供了一种不同的并发模型，也就是通信顺序进程（Communicating sequential processes，CSP）1。Goroutine 和 Channel 分别对应 CSP 中的实体和传递信息的媒介，Go 语言中的 Goroutine 会通过 Channel 传递数据。

在Go语言中，要传递某个数据给另一个 goroutine(协程)，可以把这个数据封装成一个对象，然后把这个对象的指针传入某个channel中，另一个goroutine从这个channel中读出这个指针，并处理其指向的内存对象。Go从语言层面保证同一时间只有一个goroutine能够访问channel里面的数据，为开发者提供了一种优雅简单的工具，所以Go的做法就是使用channel来通信，通过通信来传递内存数据，使得内存数据在不同的goroutine中传递，而不是使用共享内存来通信
