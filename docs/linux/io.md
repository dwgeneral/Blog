> 本篇文章从Linux文件系统的角度解读一下常见的几种IO模型工作方式

#### 文件系统I/O场景

我们都知道，在Linux中一切皆文件，不仅普通的文件和目录，就连块设备、套接字、管道等，都要通过统一的文件系统来管理。

为了支持各种不同的文件系统，Linux内核在用户进程和文件系统的中间，又引入了一个抽象层，虚拟文件系统(VFS)。VFS 定义了一组所有文件系统都支持的数据结构和标准接口。这样，用户进程和内核中的其他子系统，只需要跟 VFS 提供的统一接口进行交互就可以了，而不需要再关心底层各种文件系统的实现细节。 下图为Linux文件系统架构图

![linux-fs](../assets/linux-fs.png)

底层的文件系统需要先挂载到 VFS 目录树中的某个子目录(称为挂载点),然后才能被访问其中文件。
挂载完成后，VFS提供了一组标准的文件访问接口。这些接口以系统调用的方式，提供给应用程序使用。也就有了文件系统I/O场景。

#### 文件读写I/O模型的分类

文件读写方式的各种差异，导致I/O的分类多种多样，最常见的有，缓冲与非缓冲I/O，直接与非直接I/O，阻塞与非阻塞I/O，同步与异步I/O等。

- 根据是否利用标准库缓存，可以把文件I/O分为
  - 缓冲I/O：指利用标准库缓存来加速文件的访问，而标准库内部再通过系统调用访问文件
  - 非缓冲I/O：指直接通过系统调用来访问文件，不再经过标准库缓存

- 根据是否利用操作系统页缓存，可以把文件I/O分为
  - 直接I/O：指跳过操作系统的页缓存，直接根文件系统交互来访问文件
  - 非直接I/O：指文件读写时，先要经过系统的页缓存，再由内核或额外的系统调用，真正写入磁盘

- 根据应用程序是否阻塞自身运行，可以把文件I/O分为
  - 阻塞I/O：指应用程序执行I/O操作后，如果没有获得响应，就会阻塞当前线程，自然就不能执行其他任务
  - 非阻塞I/O：指应用程序执行I/O操作后，不会阻塞当前线程，继续执行其他任务，随后再通过轮询或者事件通知的形式，获取调用结果

- 根据I/O响应的通知方式的不同，可以把文件I/O分为
  - 同步I/O：指系统收到I/O请求后，系统不会立刻响应应用程序，等到处理完成，系统才会通过系统调用的方式，告诉应用程序I/O结果
  - 异步I/O：指系统收到I/O请求后，系统会先告诉应用程序I/O请求已收到，随后再去异步处理，等处理完成后，系统再通过事件通知的方式，告诉应用程序结果

你可以看出，阻塞/非阻塞和同步/异步，其实就是两个不同角度的I/O 划分方式。它们描述的对象也不同，阻塞/非阻塞针对的是I/O 调用者（即应用程序），而同步/异步针对的是I/O 执行者（即系统）。

#### 网络编程中的I/O模型

Linux网络编程中，阐述了五种I/O模型，分别为：
  - 阻塞式IO（blocking IO）
  - 非阻塞式IO（non-blocking IO）
  - IO复用（IO multiplexing）
  - 信号驱动式IO（signal driven IO）
  - 异步IO（asynchronous IO）

...TODO

#### 参考资料
- 《UNIX网络编程.卷1》
- 《Linux性能优化实战》